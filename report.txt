cmd/user/service/check_user.go:12: File is not `gofumpt`-ed (gofumpt)

cmd/user/service/get_user.go:10: File is not `gofumpt`-ed (gofumpt)

cmd/user/service/get_user.go:13: File is not `gofumpt`-ed (gofumpt)

cmd/user/service/get_user.go:9: unnecessary leading newline (whitespace)
func (s *UserService) GetUser(req *user.InfoRequest) (*db.User, error) {

cmd/user/service/service.go:6:2: found a struct that contains a context.Context field (containedctx)
	ctx context.Context
	^
cmd/video/handler.go:76:15: Error return value of `stream.Send` is not checked (errcheck)
			stream.Send(resp)
			           ^
cmd/video/handler.go:82:15: Error return value of `stream.Send` is not checked (errcheck)
			stream.Send(resp)
			           ^
cmd/video/handler.go:98:16: Error return value of `stream.Send` is not checked (errcheck)
				stream.Send(resp)
				           ^
cmd/video/handler.go:63: Function 'PutVideo' is too long (73 > 60) (funlen)
func (s *VideoServiceImpl) PutVideo(stream video.VideoService_PutVideoServer) (err error) {
cmd/video/handler.go:45:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//获取user信息
	^
cmd/video/handler.go:65:2: commentFormatting: put a space between `//` and comment text (gocritic)
	//追加位置
	^
cmd/video/handler.go:91:24: commentFormatting: put a space between `//` and comment text (gocritic)
		if !req.IsFinished { //上传一部分视频
		                     ^
cmd/video/handler.go:115:4: var-naming: var playUrl should be playURL (revive)
			playUrl := fmt.Sprintf("%s/%s/%s", config.OSS.Endpoint, config.OSS.MainDirectory, videoName)
			^
cmd/video/handler.go:116:4: var-naming: var coverUrl should be coverURL (revive)
			coverUrl := fmt.Sprintf("%s/%s/%s", config.OSS.Endpoint, config.OSS.MainDirectory, coverName)
			^
cmd/video/handler.go:92:20: context-keys-type: should not use basic type string as key in context.WithValue (revive)
			uploadContext = context.WithValue(stream.Context(), "nextPos", nextPos)
			                ^
cmd/video/handler.go:93:20: context-keys-type: should not use basic type string as key in context.WithValue (revive)
			uploadContext = context.WithValue(uploadContext, "videoName", videoName)
			                ^
cmd/video/handler.go:106:20: context-keys-type: should not use basic type string as key in context.WithValue (revive)
			uploadContext = context.WithValue(stream.Context(), "coverName", coverName)
			                ^
cmd/video/handler.go:66:22: var-declaration: should drop = 0 from declaration of var nextPos; it is the zero value (revive)
	var nextPos int64 = 0
	                    ^
cmd/video/handler.go:133: unnecessary trailing newline (whitespace)

	}
cmd/video/handler.go:25:2: if statements should only be cuddled with assignments used in the if statement itself (wsl)
	if req.LatestTime == 0 {
	^
cmd/video/handler.go:28:2: if statements should only be cuddled with assignments (wsl)
	if req.Token == "" {
	^
cmd/video/handler.go:57:2: assignments should only be cuddled with other assignments (wsl)
	resp.Base = pack.BuildBaseResp(nil)
	^
cmd/video/handler.go:60:2: return statements should not be cuddled if block has more than two lines (wsl)
	return
	^
cmd/video/handler.go:67:2: declarations should never be cuddled (wsl)
	var coverName string
	^
cmd/video/handler.go:68:2: declarations should never be cuddled (wsl)
	var videoName string
	^
cmd/video/handler.go:69:2: declarations should never be cuddled (wsl)
	var uploadContext context.Context
	^
cmd/video/handler.go:134:2: block should not end with a whitespace (or comment) (wsl)
	}
	^
cmd/video/handler.go:77:4: return statements should not be cuddled if block has more than two lines (wsl)
			return nil
			^
cmd/video/handler.go:83:4: return statements should not be cuddled if block has more than two lines (wsl)
			return nil
			^
cmd/video/handler.go:79:3: if statements should only be cuddled with assignments (wsl)
		if _, err := utils.CheckToken(req.Token); err != nil {
		^
cmd/video/handler.go:85:3: if statements should only be cuddled with assignments (wsl)
		if coverName == "" {
		^
cmd/video/handler.go:95:4: only one cuddle assignment allowed before if statement (wsl)
			if err != nil {
			^
cmd/video/handler.go:101:4: assignments should only be cuddled with other assignments (wsl)
			resp.Base = pack.BuildBaseResp(nil)
			^
cmd/video/handler.go:71:2: for statement without condition should never be cuddled (wsl)
	for {
	^
cmd/video/handler.go:150:2: assignments should only be cuddled with other assignments (wsl)
	videoList, err := service.NewVideoService(ctx).GetFavoriteVideoInfo(req)
	^
cmd/video/handler.go:151:2: only one cuddle assignment allowed before if statement (wsl)
	if err != nil {
	^
cmd/video/handler.go:184:2: only one cuddle assignment allowed before if statement (wsl)
	if err != nil {
	^
cmd/video/handler.go:29:38: mnd: Magic number: 10000, in <argument> detected (gomnd)
		req.Token, err = utils.CreateToken(10000)
		                                   ^
cmd/chat/dal/db/chat.go:35: Function 'GetMessageList' has too many statements (46 > 40) (funlen)
func GetMessageList(ctx context.Context, to_user_id int64, from_user_id int64) ([]*Message, bool, error) {
cmd/chat/dal/db/init.go:12:6: exported: type name will be used as db.DBAction by other packages, and that stutters; consider calling this Action (revive)
type DBAction struct {
     ^
cmd/chat/dal/db/chat.go:17:2: var-naming: struct field Id should be ID (revive)
	Id         int64
	^
cmd/chat/dal/db/chat.go:18:2: var-naming: struct field ToUserId should be ToUserID (revive)
	ToUserId   int64
	^
cmd/chat/dal/db/chat.go:19:2: var-naming: struct field FromUserId should be FromUserID (revive)
	FromUserId int64
	^
cmd/chat/dal/db/chat.go:26:2: var-naming: struct field Id should be ID (revive)
	Id         int64
	^
cmd/chat/dal/db/chat.go:27:2: var-naming: struct field ToUserId should be ToUserID (revive)
	ToUserId   int64
	^
cmd/chat/dal/db/chat.go:28:2: var-naming: struct field FromUserId should be FromUserID (revive)
	FromUserId int64
	^
cmd/chat/dal/db/chat.go:89:25: unnecessary conversion (unconvert)
		sort.Sort(MessageArray(messageList))
		                      ^
cmd/chat/dal/db/chat.go:61:4: append only allowed to cuddle with appended value (wsl)
			messageList = append(messageList, message)
			^
cmd/chat/dal/db/chat.go:84:4: append only allowed to cuddle with appended value (wsl)
			messageList = append(messageList, message)
			^
cmd/chat/dal/db/init.go:44:2: expressions should not be cuddled with blocks (wsl)
	sqlDB.SetMaxIdleConns(constants.MaxIdleConns)       // 最大闲置连接数
	^
cmd/chat/dal/db/init.go:49:2: if statements should only be cuddled with assignments used in the if statement itself (wsl)
	if SF, err = utils.NewSnowflake(constants.SnowflakeDatacenterID, constants.SnowflakeWorkerID); err != nil {
	^
cmd/chat/dal/db/chat.go:104:23: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"user not found\")" (goerr113)
			return nil, false, errors.New("user not found")
			                   ^
cmd/chat/dal/db/init.go:18:2: variable name 'SF' is too short for the scope of its usage (varnamelen)
	SF *utils.Snowflake
	^
cmd/chat/dal/db/init.go:17:2: variable name 'DB' is too short for the scope of its usage (varnamelen)
	DB *gorm.DB
	^
cmd/follow/service/action.go:29:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if req.ActionType == 1 {
	^
cmd/follow/service/follow_list.go:21:2: Consider pre-allocating `userList` (prealloc)
	var userList []*follow.User
	^
cmd/follow/service/follower_list.go:21:2: Consider pre-allocating `userList` (prealloc)
	var userList []*follow.User
	^
cmd/follow/service/friend_list.go:22:2: Consider pre-allocating `friendList` (prealloc)
	var friendList []*follow.FriendUser
	^
cmd/follow/service/friend_list.go:63: unnecessary trailing newline (whitespace)

	}
cmd/follow/service/friend_list.go:64:2: block should not end with a whitespace (or comment) (wsl)
	}
	^
cmd/follow/service/service.go:6:2: found a struct that contains a context.Context field (containedctx)
	ctx context.Context
	^
cmd/follow/service/follow_list.go:30:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you are not following anyone\")" (goerr113)
			return nil, errors.New("you are not following anyone")
			            ^
cmd/follow/service/follower_list.go:30:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you do not have any followers\")" (goerr113)
			return nil, errors.New("you do not have any followers")
			            ^
cmd/follow/service/friend_list.go:31:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you do not have any friends\")" (goerr113)
			return nil, errors.New("you do not have any friends")
			            ^
cmd/follow/service/action.go:38:30: mnd: Magic number: 2, in <condition> detected (gomnd)
	} else if req.ActionType == 2 {
	                            ^
cmd/follow/service/friend_list.go:38:6: variable name 'id' is too short for the scope of its usage (varnamelen)
	for _, id := range *userList {
	    ^
cmd/user/dal/db/user.go:13:2: var-naming: struct field Id should be ID (revive)
	Id              int64
	^
cmd/user/dal/db/user.go:58:16: block should not start with a whitespace (wsl)
	if err != nil {
	              ^
cmd/user/dal/db/user.go:75:16: block should not start with a whitespace (wsl)
	if err != nil {
	              ^
cmd/user/dal/db/user.go:79:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"User not found\")" (goerr113)
			return nil, errors.New("User not found")
			            ^
cmd/user/dal/db/init.go:14:5: variable name 'SF' is too short for the scope of its usage (varnamelen)
var SF *utils.Snowflake
    ^
cmd/user/pack/user.go:23:1: block should not end with a whitespace (or comment) (wsl)
}
^
cmd/follow/dal/db/follow.go:95:2: Consider pre-allocating `friendList` (prealloc)
	var friendList []int64
	^
cmd/follow/dal/db/follow.go:14:2: var-naming: struct field UserId should be UserID (revive)
	UserId    int64
	^
cmd/follow/dal/db/follow.go:15:2: var-naming: struct field ToUserId should be ToUserID (revive)
	ToUserId  int64
	^
cmd/follow/dal/db/init.go:13:5: variable name 'SF' is too short for the scope of its usage (varnamelen)
var SF *utils.Snowflake
    ^
cmd/follow/dal/db/follow.go:104:6: variable name 'id' is too short for the scope of its usage (varnamelen)
	for _, id := range *tempList {
	    ^
cmd/interaction/dal/db/favorite.go:37:2: if-return: redundant if ...; err != nil check, just return error instead. (revive)
	if err := DB.Table(constants.FavoriteTableName).WithContext(ctx).Create(fav).Error; err != nil {
		return err
	}
cmd/interaction/dal/db/favorite.go:44:2: if-return: redundant if ...; err != nil check, just return error instead. (revive)
	if err := DB.Table(constants.FavoriteTableName).WithContext(ctx).
		Where("user_id = ? AND video_id = ?", userId, videoId).Update("status", status).Error; err != nil {
		return err
	}
cmd/interaction/dal/db/comment.go:14:2: var-naming: struct field UserId should be UserID (revive)
	UserId    int64          `msg:"u"`
	^
cmd/interaction/dal/db/comment.go:15:2: var-naming: struct field VideoId should be VideoID (revive)
	VideoId   int64          `msg:"-"`
	^
cmd/interaction/dal/db/comment.go:40:42: var-naming: func parameter commentId should be commentID (revive)
func GetCommentByID(ctx context.Context, commentId int64) (*Comment, error) {
                                         ^
cmd/interaction/dal/db/comment.go:56:48: var-naming: func parameter videoId should be videoID (revive)
func GetCommentsByVideoID(ctx context.Context, videoId int64) ([]Comment, error) {
                                               ^
cmd/interaction/dal/db/favorite.go:14:2: var-naming: struct field UserId should be UserID (revive)
	UserId    int64
	^
cmd/interaction/dal/db/comment.go:69:50: var-naming: func parameter videoId should be videoID (revive)
func CountCommentsByVideoID(ctx context.Context, videoId int64) (int64, error) {
                                                 ^
cmd/interaction/dal/db/favorite.go:15:2: var-naming: struct field VideoId should be VideoID (revive)
	VideoId   int64
	^
cmd/interaction/dal/db/favorite.go:22:43: var-naming: func parameter userId should be userID (revive)
func IsFavoriteExist(ctx context.Context, userId int64, videoId int64) (bool, error) {
                                          ^
cmd/interaction/dal/db/favorite.go:43:48: var-naming: func parameter userId should be userID (revive)
func UpdateFavoriteStatus(ctx context.Context, userId int64, videoId int64, status int64) error {
                                               ^
cmd/interaction/dal/db/favorite.go:51:6: var-naming: func GetVideosByUserId should be GetVideosByUserID (revive)
func GetVideosByUserId(ctx context.Context, userId int64) ([]int64, error) {
     ^
cmd/interaction/dal/db/favorite.go:66:45: var-naming: func parameter videoId should be videoID (revive)
func GetVideoLikeCount(ctx context.Context, videoId int64) (int64, error) {
                                            ^
cmd/interaction/dal/db/comment.go:22: unnecessary leading newline (whitespace)
func CreateComment(ctx context.Context, comment *Comment) (*Comment, error) {

cmd/interaction/dal/db/comment.go:45: unnecessary leading newline (whitespace)
	if err != nil {

cmd/interaction/dal/db/comment.go:48:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"comment not found\")" (goerr113)
			return nil, errors.New("comment not found")
			            ^
cmd/interaction/dal/db/init.go:43:6: ineffectual assignment to err (ineffassign)
	SF, err = utils.NewSnowflake(constants.SnowflakeDatacenterID, constants.SnowflakeWorkerID)
	    ^
cmd/interaction/service/favorite_list.go:14:2: var-naming: var videoIdList should be videoIDList (revive)
	videoIdList, err := cache.GetUserFavoriteVideos(s.ctx, req.UserId)
	^
cmd/interaction/service/count_comments.go:11:2: var-naming: var videoId should be videoID (revive)
	videoId := req.VideoId
	^
cmd/interaction/service/like.go:11:75: var-naming: method parameter userId should be userID (revive)
func (s *InteractionService) Like(req *interaction.FavoriteActionRequest, userId int64) error {
                                                                          ^
cmd/interaction/service/dislike.go:11:78: var-naming: method parameter userId should be userID (revive)
func (s *InteractionService) Dislike(req *interaction.FavoriteActionRequest, userId int64) error {
                                                                             ^
cmd/interaction/service/dislike.go:33:2: if-return: redundant if ...; err != nil check, just return error instead. (revive)
	if err := db.UpdateFavoriteStatus(s.ctx, userId, req.VideoId, 0); err != nil {
		return err
	}
cmd/interaction/service/get_comments.go:48: unnecessary trailing newline (whitespace)

	}
cmd/interaction/service/get_comments.go:26:3: only one cuddle assignment allowed before range statement (wsl)
		for _, rComment := range *rComments {
		^
cmd/interaction/service/service.go:6:2: found a struct that contains a context.Context field (containedctx)
	ctx context.Context
	^
cmd/interaction/service/favorite_list.go:15:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == redis.Nil {
	   ^
cmd/interaction/service/get_like_count.go:15:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == redis.Nil {
	   ^
cmd/interaction/service/dislike.go:17:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you did not like this video\")" (goerr113)
		return errors.New("you did not like this video")
		       ^
cmd/interaction/service/dislike.go:30:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you did not like this video\")" (goerr113)
		return errors.New("you did not like this video")
		       ^
cmd/interaction/service/favorite_list.go:16:15: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you have no favorite video\")" (goerr113)
		return nil, errors.New("you have no favorite video")
		            ^
cmd/interaction/service/favorite_list.go:31:23: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"update cache fail\")" (goerr113)
		return videoIdList, errors.New("update cache fail")
		                    ^
cmd/interaction/service/get_like_count.go:16:13: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"this video has no like\")" (goerr113)
		return 0, errors.New("this video has no like")
		          ^
cmd/interaction/service/like.go:17:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you already like the video\")" (goerr113)
		return errors.New("you already like the video")
		       ^
cmd/chat/main.go:41:2: variable name 'r' is too short for the scope of its usage (varnamelen)
	r, err := etcd.NewEtcdRegistry([]string{config.Etcd.Addr})
	^
cmd/follow/main.go:41:2: variable name 'r' is too short for the scope of its usage (varnamelen)
	r, err := etcd.NewEtcdRegistry([]string{config.Etcd.Addr})
	^
pkg/utils/sensitive_words.go:30:9: wrapperFunc: use strings.ReplaceAll method in `strings.Replace(text, " ", "", -1)` (gocritic)
	text = strings.Replace(text, " ", "", -1) // 去除空格
	       ^
pkg/utils/encode.go:4:2: G501: Blocklisted import crypto/md5: weak cryptographic primitive (gosec)
	"crypto/md5"
	^
pkg/utils/encode.go:12:7: G401: Use of weak cryptographic primitive (gosec)
	h := md5.New()
	     ^
pkg/utils/encode.go:18:7: G401: Use of weak cryptographic primitive (gosec)
	h := md5.New()
	     ^
pkg/utils/sensitive_words.go:100:9: indent-error-flow: if block ends with a return statement, so drop this else and outdent its block (move short variable declaration to its own line if necessary) (revive)
	} else {
		// 不存在
		tn.childMap[c] = &TrieNode{
			childMap: nil,
			End:      false,
		}
		return tn.childMap[c]
	}
pkg/utils/jwt.go:15:18: var-naming: func parameter userId should be userID (revive)
func CreateToken(userId int64) (string, error) {
                 ^
pkg/utils/snowflake.go:74:12: unnecessary conversion (unconvert)
	r := int64((t)<<timestampShift | (s.datacenterid << datacenteridShift) | (s.workerid << workeridShift) | (s.sequence))
	          ^
pkg/utils/sensitive_words.go:43:2: only one cuddle assignment allowed before range statement (wsl)
	for _, charInt := range sensitiveWord {
	^
pkg/utils/sensitive_words.go:66:2: only one cuddle assignment allowed before for statement (wsl)
	for i, textLen := 0, len(textChars); i < textLen; i++ {
	^
pkg/utils/snowflake.go:36:15: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"datacenterid must be between 0 and %d\", datacenteridMax-1)" (goerr113)
		return nil, fmt.Errorf("datacenterid must be between 0 and %d", datacenteridMax-1)
		            ^
pkg/utils/snowflake.go:39:15: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"workerid must be between 0 and %d\", workeridMax-1)" (goerr113)
		return nil, fmt.Errorf("workerid must be between 0 and %d", workeridMax-1)
		            ^
pkg/utils/snowflake.go:101:37: mnd: Magic number: 1000, in <argument> detected (gomnd)
	t = time.Unix(GetGenTimestamp(sid)/1000, 0).Format("2006-01-02 15:04:05")
	                                   ^
pkg/utils/snowflake.go:52:33: mnd: Magic number: 1000000, in <operation> detected (gomnd)
	now := time.Now().UnixNano() / 1000000 // 转毫秒
	                               ^
pkg/utils/snowflake.go:60:35: mnd: Magic number: 1000000, in <operation> detected (gomnd)
				now = time.Now().UnixNano() / 1000000
				                              ^
pkg/utils/sensitive_words.go:73:3: variable name 'j' is too short for the scope of its usage (varnamelen)
		j := i + 1
		^
pkg/utils/utils.go:32:2: variable name 'l' is too short for the scope of its usage (varnamelen)
	l, err := net.Listen("tcp", addr)
	^
cmd/interaction/dal/cache/comment.go:32:15: underef: could simplify (*comment).MarshalMsg to comment.MarshalMsg (gocritic)
	data, err := (*comment).MarshalMsg(nil)
	             ^
cmd/interaction/dal/cache/comment.go:71:15: underef: could simplify (*comment).MarshalMsg to comment.MarshalMsg (gocritic)
	data, err := (*comment).MarshalMsg(nil)
	             ^
cmd/interaction/dal/cache/comment.go:47:2: Consider pre-allocating `zComments` (prealloc)
	var zComments []redis.Z
	^
cmd/interaction/dal/cache/favorite.go:64:2: var-naming: var videoIdList should be videoIDList (revive)
	videoIdList := make([]int64, 10)
	^
cmd/interaction/dal/cache/favorite.go:66:3: var-naming: var videoId should be videoID (revive)
		videoId, err := strconv.ParseInt(item, 10, 64)
		^
cmd/interaction/dal/cache/comment.go:27:2: expressions should not be cuddled with blocks (wsl)
	klog.Infof("Get comments : videoId %v: %v\n", key, rComments)
	^
cmd/interaction/dal/cache/comment.go:54:3: append only allowed to cuddle with appended value (wsl)
		zComments = append(zComments, redis.Z{Score: float64(comment.CreatedAt.Unix()), Member: data})
		^
cmd/interaction/dal/cache/comment.go:48:2: ranges should only be cuddled with assignments used in the iteration (wsl)
	for _, comment := range *comments {
	^
cmd/interaction/dal/cache/favorite.go:65:2: ranges should only be cuddled with assignments used in the iteration (wsl)
	for _, item := range items {
	^
cmd/video/rpc/user.go:19:2: variable name 'r' is too short for the scope of its usage (varnamelen)
	r, err := etcd.NewEtcdResolver([]string{config.Etcd.Addr})
	^
cmd/video/rpc/user.go:25:2: variable name 'c' is too short for the scope of its usage (varnamelen)
	c, err := userservice.NewClient(
	^
test/chat/get_message_test.go:1: File is not `gofmt`-ed with `-s` (gofmt)
package test

import (
	"strconv"
	"testing"
	"time"

	"github.com/ozline/tiktok/kitex_gen/chat"
	"github.com/ozline/tiktok/pkg/utils"
)

func testGetMessage(t *testing.T) {
	t.Log("------------testGetMessage Start---------------")
	token, err := utils.CreateToken(from_user_id)
	if err != nil {
		t.Error(err)
		t.Fail()
	}
	req := &chat.MessageListRequest{
		Token:    token,
		ToUserId: to_user_id,
	}
	resp, err := chatService.GetMessages(req, from_user_id)
	if err != nil {
		t.Error(err)
		t.Fail()
	}
	for _, v := range resp {
		t.Log(("-----------------------------"))
		t.Log(v)
	}
	t.Log("------------testGetMessage End---------------")

}

func benchmarkGetAndPostMessage(b *testing.B) {
	b.Log("-----benchmarkGetAndPostMessage Start-----")
	token, err := utils.CreateToken(from_user_id)
	if err != nil {
		b.Error(err)
		b.Fail()
	}
	req := &chat.MessageListRequest{
		Token:    token,
		ToUserId: to_user_id,
	}

	// b.N = 1
	for i := 0; i < b.N; i++ {
		b.Logf("----epoch:%v ----", i)
		for i := 0; i < 2000; i++ {
			_, err := chatService.GetMessages(req, from_user_id)
			if err != nil {
				b.Error(err)
				b.Fail()
			}
			now := time.Now().Format("2006-01-02 15:04:05")
			req_post := &chat.MessagePostRequest{
				Token:      token,
				FromUserId: from_user_id,
				ToUserId:   to_user_id,
				Content:    content_get + "-->" + strconv.FormatInt(int64(i), 10),
				CreateTime: &now,
			}
			err = chatService.SendMessage(req_post)
			if err != nil {
				b.Error(err)
				b.Fail()
			}

		}
	}
	b.Log("-----benchmarkGetAndPostMessage End-----")
}
test/chat/post_message_test.go:1: File is not `gofmt`-ed with `-s` (gofmt)
package test

import (
	"strconv"
	"testing"
	"time"

	"github.com/cloudwego/kitex/pkg/klog"
	"github.com/ozline/tiktok/kitex_gen/chat"
	"github.com/ozline/tiktok/pkg/utils"
)

func testPostMessage(t *testing.T) {
	t.Log("------------testPostMessage Start---------------")
	token, err := utils.CreateToken(from_user_id)
	if err != nil {
		klog.Info(err)
	}
	now := time.Now().Format("2006-01-02 15:04:05")
	req := &chat.MessagePostRequest{
		Token:      token,
		FromUserId: from_user_id,
		ToUserId:   to_user_id,
		Content:    content_post,
		CreateTime: &now,
	}
	err = chatService.SendMessage(req)
	if err != nil {
		t.Error(err)
		t.Fail()
	}
	time.Sleep(time.Second * 4)
	t.Log("------------testPostMessage End---------------")
}

func benchmarkPostMessage(b *testing.B) {
	b.Log("------------benchmarkPostMessage Start---------------")
	token, err := utils.CreateToken(from_user_id)
	if err != nil {
		b.Error(err)
		b.Fail()
	}
	// b.N = 10
	for i := 0; i < b.N; i++ {
		for i := 0; i < 2000; i++ {
			now := time.Now().Format("2006-01-02 15:04:05")
			req := &chat.MessagePostRequest{
				Token:      token,
				FromUserId: from_user_id,
				ToUserId:   to_user_id,
				Content:    content_post + "-->" + strconv.FormatInt(int64(i), 10),
				CreateTime: &now,
			}
			err = chatService.SendMessage(req)
			if err != nil {
				b.Error(err)
				b.Fail()
			}
		}
	}
	b.Log("------------benchmarkPostMessage End---------------")
}
test/chat/main_test.go:13:2: var-naming: don't use underscores in Go names; var from_user_id should be fromUserID (revive)
	from_user_id int64  = 2
	^
test/chat/main_test.go:14:2: var-naming: don't use underscores in Go names; var to_user_id should be toUserID (revive)
	to_user_id   int64  = 3
	^
test/chat/main_test.go:15:2: var-naming: don't use underscores in Go names; var content_get should be contentGet (revive)
	content_get  string = "test get"
	^
test/chat/get_message_test.go:58:4: var-naming: don't use underscores in Go names; var req_post should be reqPost (revive)
			req_post := &chat.MessagePostRequest{
			^
test/chat/main_test.go:16:2: var-naming: don't use underscores in Go names; var content_post should be contentPost (revive)
	content_post string = "test post"
	^
test/chat/rpc_test.go:11:6: var-naming: func testRpc should be testRPC (revive)
func testRpc(t *testing.T) {
     ^
test/chat/db_test.go:15:2: expressions should not be cuddled with blocks (wsl)
	t.Log("------------TestDB End------------")
	^
test/chat/get_message_test.go:28:2: only one cuddle assignment allowed before range statement (wsl)
	for _, v := range resp {
	^
test/chat/get_message_test.go:51:3: for statements should only be cuddled with assignments used in the iteration (wsl)
		for i := 0; i < 2000; i++ {
		^
test/chat/main_test.go:25:2: only cuddled expressions if assigning variable or using from line above (wsl)
	m.Run()
	^
test/chat/main_test.go:29:2: Function TestMainOrder missing the call to method parallel in the test run (paralleltest)
	t.Run("rpc", testRpc)
	^
test/chat/main_test.go:31:2: Function TestMainOrder missing the call to method parallel in the test run (paralleltest)
	t.Run("get_message", testGetMessage)
	^
test/chat/main_test.go:33:2: Function TestMainOrder missing the call to method parallel in the test run (paralleltest)
	t.Run("post_message", testPostMessage)
	^
test/chat/db_test.go:1:9: package should be `test_test` instead of `test` (testpackage)
package test
        ^
test/chat/main_test.go:1:9: package should be `test_test` instead of `test` (testpackage)
package test
        ^
test/chat/redis_test.go:1:9: package should be `test_test` instead of `test` (testpackage)
package test
        ^
test/chat/post_message_test.go:45:7: variable name 'i' is too short for the scope of its usage (varnamelen)
		for i := 0; i < 2000; i++ {
		    ^
pkg/errno/default.go:7:2: the variable name `Success` should conform to the `ErrXxx` format (errname)
	Success = NewErrNo(SuccessCode, "Success")
	^
pkg/errno/default.go:9:2: the variable name `ServiceError` should conform to the `ErrXxx` format (errname)
	ServiceError             = NewErrNo(ServiceErrorCode, "service is unable to start successfully")
	^
pkg/errno/default.go:10:2: the variable name `ServiceInternalError` should conform to the `ErrXxx` format (errname)
	ServiceInternalError     = NewErrNo(ServiceErrorCode, "service internal error")
	^
pkg/errno/default.go:11:2: the variable name `ParamError` should conform to the `ErrXxx` format (errname)
	ParamError               = NewErrNo(ParamErrorCode, "parameter error")
	^
pkg/errno/default.go:12:2: the variable name `AuthorizationFailedError` should conform to the `ErrXxx` format (errname)
	AuthorizationFailedError = NewErrNo(AuthorizationFailedErrCode, "authorization failed")
	^
pkg/errno/default.go:15:2: the variable name `UserExistedError` should conform to the `ErrXxx` format (errname)
	UserExistedError = NewErrNo(ParamErrorCode, "user existed")
	^
pkg/errno/default.go:18:2: the variable name `UnexpectedTypeError` should conform to the `ErrXxx` format (errname)
	UnexpectedTypeError     = NewErrNo(UnexpectedTypeErrorCode, "unexpected type")
	^
pkg/errno/default.go:19:2: the variable name `NotImplementError` should conform to the `ErrXxx` format (errname)
	NotImplementError       = NewErrNo(NotImplementErrorCode, "not implement")
	^
pkg/errno/default.go:20:2: the variable name `SensitiveWordsError` should conform to the `ErrXxx` format (errname)
	SensitiveWordsError     = NewErrNo(SensitiveWordsErrorCode, "existed sensitive words")
	^
pkg/errno/default.go:21:2: the variable name `SensitiveWordsHTTPError` should conform to the `ErrXxx` format (errname)
	SensitiveWordsHTTPError = NewErrNo(ServiceErrorCode, "sensitive-words api error")
	^
config/config.go:60:33: unexported-return: exported func GetService returns unexported type *config.service, which can be annoying to use (revive)
func GetService(srvname string) *service {
                                ^
config/config.go:31:15: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		            ^
config/config.go:43:2: variable name 'c' is too short for the scope of its usage (varnamelen)
	c := new(config)
	^
cmd/video/pack/video.go:83:24: captLocal: `UserId' should not be capitalized (gocritic)
func GenerateVideoName(UserId int64) string {
                       ^
cmd/video/pack/video.go:90:24: captLocal: `UserId' should not be capitalized (gocritic)
func GenerateCoverName(UserId int64) string {
                       ^
pkg/constants/constants.go:9:2: var-naming: don't use underscores in Go names; const ReidsDB_Chat should be ReidsDBChat (revive)
	ReidsDB_Chat       = 1
	^
cmd/chat/dal/mq/chat_mq.go:1: File is not `gofmt`-ed with `-s` (gofmt)
package mq

import (
	"context"
	"strconv"
	"time"

	"github.com/bytedance/sonic"
	"github.com/cloudwego/kitex/pkg/klog"
	"github.com/ozline/tiktok/cmd/chat/dal/cache"
	"github.com/ozline/tiktok/cmd/chat/dal/db"

	amqp "github.com/rabbitmq/amqp091-go"
)

var ChatMQCli *ChatMQ

type ChatMQ struct {
	RabbitMQ
	channel   *amqp.Channel
	exchange  string
	queueName string
}

func NewChatMQ(queueName string) *ChatMQ {
	ChatMQCli := &ChatMQ{
		RabbitMQ:  *Rmq,
		queueName: queueName, //friendQue groupQue
	}

	ch, err := ChatMQCli.conn.Channel()
	if err != nil {

		return nil
	}
	ChatMQCli.channel = ch
	return ChatMQCli
}

func InitChatMQ() {
	ChatMQCli = NewChatMQ("chatQueue")
	go ChatMQCli.Consumer()
}

func (c *ChatMQ) Publish(ctx context.Context, message string) error {

	klog.Info("queueName ->:", c.queueName)
	_, err := c.channel.QueueDeclare(
		c.queueName,
		//是否持久化
		false,
		//是否为自动删除
		false,
		//是否具有排他性
		false,
		//是否阻塞
		false,
		//额外属性
		nil,
	)
	if err != nil {
		return err
	}
	//json.marshal 可序列化结构体为二进制byte类型
	//然后就可以通过消息队列进行传参，
	//在消费者方面只需要通过unmarshal进行反序列化就可以得到结构体

	err = c.channel.PublishWithContext(ctx,
		c.exchange,
		c.queueName,
		false,
		false,
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        []byte(message),
		})
	if err != nil {
		return err
	}
	return nil
}

func (r *ChatMQ) Consumer() {
	defer r.destroy()
	_, err := r.channel.QueueDeclare(r.queueName, false, false, false, false, nil)

	if err != nil {
		return
	}
	klog.Info("consume queuename--->", r.queueName)
	//2、接收消息
	msg, err := r.channel.Consume(
		r.queueName,
		//用来区分多个消费者
		"",
		//是否自动应答
		true,
		//是否具有排他性
		false,
		//如果设置为true，表示不能将同一个connection中发送的消息传递给这个connection中的消费者
		false,
		//消息队列是否阻塞
		false,
		nil,
	)
	if err != nil {
		klog.Info(err)
		return
	}
	klog.Info("[*] Waiting for messages,To exit press CTRL+C")
	go r.DealWithMessageToUser(msg)
	//log.Printf("[*] Waiting for messages,To exit press CTRL+C")
	forever := make(chan bool)
	<-forever
}
func (c *ChatMQ) DealWithMessageToUser(msg <-chan amqp.Delivery) {
	for req := range msg {
		klog.Info("chatMQ consuming")
		middle_message := new(MiddleMessage)
		err := sonic.Unmarshal(req.Body, middle_message)
		if err != nil {
			klog.Info(err)
			continue
		}
		//先存mysql，然后存redis
		klog.Info("chatMQ consuming")
		message := new(cache.Message)
		err = convertForMysql(message, middle_message)
		if err != nil {
			klog.Info(err)
			continue
		}
		err = db.DB.Create(&message).Error
		if err != nil {
			klog.Info(err)
			continue
		}
		klog.Info("chatMQ consuming")
		key := strconv.FormatInt(message.FromUserId, 10) + "-" + strconv.FormatInt(message.ToUserId, 10)
		err = cache.MessageInsert(context.TODO(), key, float64(message.CreatedAt.Unix()), string(req.Body))
		if err != nil {
			klog.Info(err)
			continue
		}
	}
}

func convertForMysql(message *cache.Message, tempMessage *MiddleMessage) (err error) {
	message.Id = tempMessage.Id
	message.ToUserId = tempMessage.ToUserId
	message.FromUserId = tempMessage.FromUserId
	message.Content = tempMessage.Content
	message.CreatedAt, err = time.ParseInLocation(time.RFC3339, tempMessage.CreatedAt, time.Local)
	if err != nil {
		return err
	}
	return
}
cmd/chat/dal/mq/message_mq.go:133:4: var-naming: don't use underscores in Go names; var cre_time should be creTime (revive)
			cre_time, _ := time.ParseInLocation("2006-01-02T15:04:05Z", val.CreatedAt, time.Local)
			^
cmd/chat/dal/mq/chat_mq.go:119:3: var-naming: don't use underscores in Go names; var middle_message should be middleMessage (revive)
		middle_message := new(MiddleMessage)
		^
cmd/chat/dal/mq/init.go:15:2: var-naming: struct field FromUserId should be FromUserID (revive)
	FromUserId int64
	^
cmd/chat/dal/mq/message_mq.go:82:1: receiver-naming: receiver name r should be consistent with previous receiver name c for MessageMQ (revive)
func (r *MessageMQ) Consumer() {
	defer r.destroy()
	_, err := r.channel.QueueDeclare(r.queueName, false, false, false, false, nil)

	if err != nil {
		return
	}

	//2、接收消息
	msg, err := r.channel.Consume(
		r.queueName,
		//用来区分多个消费者
		"",
		//是否自动应答
		true,
		//是否具有排他性
		false,
		//如果设置为true，表示不能将同一个connection中发送的消息传递给这个connection中的消费者
		false,
		//消息队列是否阻塞
		false,
		nil,
	)
	if err != nil {
		return
	}
	go r.dealWithMessageToCache(msg)
	//log.Printf("[*] Waiting for messages,To exit press CTRL+C")
	forever := make(chan bool)
	<-forever
}
cmd/chat/dal/mq/chat_mq.go:111:2: only one cuddle assignment allowed before go statement (wsl)
	go r.DealWithMessageToUser(msg)
	^
cmd/chat/dal/mq/message_mq.go:108:2: only one cuddle assignment allowed before go statement (wsl)
	go r.dealWithMessageToCache(msg)
	^
cmd/chat/dal/mq/message_mq.go:127:4: branch statements should not be cuddled if block has more than two lines (wsl)
			continue
			^
cmd/video/service/feed_video.go:21:24: Error return value of `cache.AddVideoList` is not checked (errcheck)
		go cache.AddVideoList(s.ctx, videoList, req.LatestTime)
		                     ^
cmd/video/service/upload_video.go:13:2: variable name 'ok' is too short for the scope of its usage (varnamelen)
	videoName, ok := s.ctx.Value("videoName").(string)
	^
cmd/follow/dal/cache/follow.go:72:2: Consider pre-allocating `followList` (prealloc)
	var followList []int64
	^
cmd/follow/dal/cache/follow.go:93:2: Consider pre-allocating `followerList` (prealloc)
	var followerList []int64
	^
cmd/follow/dal/cache/follow.go:114:2: Consider pre-allocating `friendList` (prealloc)
	var friendList []int64
	^
cmd/follow/dal/cache/follow.go:78:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err == redis.Nil {
	   ^
cmd/follow/dal/cache/follow.go:29:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you already follow this user\")" (goerr113)
		return errors.New("you already follow this user")
		       ^
cmd/follow/dal/cache/follow.go:52:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"you are not following this user\")" (goerr113)
		return errors.New("you are not following this user")
		       ^
cmd/follow/dal/cache/limiter.go:31:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"too many request\")" (goerr113)
		return errors.New("too many request")
		       ^
cmd/follow/dal/cache/init.go:17:13: mnd: Magic number: 2, in <assign> detected (gomnd)
		DB:       2,
		          ^
cmd/follow/dal/cache/follow.go:123:6: variable name 'id' is too short for the scope of its usage (varnamelen)
	for _, id := range *tempList {
	    ^
cmd/follow/dal/cache/follow.go:15:2: variable name 'b' is too short for the scope of its usage (varnamelen)
	b, err := RedisClient.SIsMember(ctx, FollowListKey(uid), tid).Result()
	^
cmd/user/dal/cache/init.go:38:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if err == redis.Nil {
	^
cmd/chat/dal/cache/chat.go:13:2: `if ok != 0` has complex nested blocks (complexity: 5) (nestif)
	if ok := MessageExist(ctx, key); ok != 0 {
	^
cmd/chat/dal/cache/init.go:35:9: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"[redis init error]\")" (goerr113)
		panic(errors.New("[redis init error]"))
		      ^
cmd/chat/dal/cache/chat.go:26:48: mnd: Magic number: 30, in <argument> detected (gomnd)
			err = RedisDB.Expire(ctx, key, time.Hour*24*30).Err()
			                                            ^
cmd/interaction/rpc/user.go:26:2: variable name 'c' is too short for the scope of its usage (varnamelen)
	c, err := userservice.NewClient(
	^
test/follow/main_test.go:34:1: Function TestMainOrder missing the call to method parallel (paralleltest)
func TestMainOrder(t *testing.T) {
^
cmd/video/dal/cache/video.go:32:2: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Println(strconv.FormatInt(latestTime, 10))
	^
test/user/main_test.go:33:1: Function TestMainOrder missing the call to method parallel (paralleltest)
func TestMainOrder(t *testing.T) {
^
pkg/middleware/common.go:16:3: variable name 'ri' is too short for the scope of its usage (varnamelen)
		ri := rpcinfo.GetRPCInfo(ctx)
		^
cmd/interaction/handler.go:162:27: G601: Implicit memory aliasing in for loop. (gosec)
		rComment = pack.Comment(&comment)
		                        ^
cmd/interaction/handler.go:161:3: ineffectual assignment to rComment (ineffassign)
		rComment := new(interaction.Comment)
		^
cmd/interaction/handler.go:138:2: naked return in func `CommentAction` with 58 lines of code (nakedret)
	return
	^
cmd/user/dal/mq/init.go:42:59: mnd: Magic number: 5, in <argument> detected (gomnd)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	                                                         ^
cmd/user/dal/mq/init.go:21:2: variable name 'ch' is too short for the scope of its usage (varnamelen)
	ch, err := conn.Channel()
	^
cmd/user/dal/mq/init.go:29:2: variable name 'q' is too short for the scope of its usage (varnamelen)
	q, err := ch.QueueDeclare(
	^
cmd/user/handler.go:81:18: mnd: Magic number: 10000, in <condition> detected (gomnd)
	if req.UserId < 10000 {
	                ^
cmd/follow/rpc/chat.go:62:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if messageList[i].FromUserId == uid && messageList[i].ToUserId == tid {
		^
cmd/interaction/dal/sensitive_words/init.go:8: File is not `goimports`-ed (goimports)

cmd/interaction/dal/sensitive_words/init.go:12:5: variable name 'St' is too short for the scope of its usage (varnamelen)
var St *utils.SensitiveTrie
    ^
test/video/main_test.go:26:2: only cuddled expressions if assigning variable or using from line above (wsl)
	m.Run()
	^
test/video/main_test.go:29:1: Function TestMainOrder missing the call to method parallel (paralleltest)
func TestMainOrder(t *testing.T) {
^
cmd/interaction/pack/comment.go:26:22: G601: Implicit memory aliasing in for loop. (gosec)
		comment := Comment(&item)
		                   ^
cmd/interaction/pack/comment.go:24:2: Consider pre-allocating `comments` (prealloc)
	var comments []*interaction.Comment
	^
cmd/interaction/pack/comment.go:25:2: ranges should only be cuddled with assignments used in the iteration (wsl)
	for _, item := range *data {
	^
cmd/interaction/pack/favorite.go:54:39: mnd: Magic number: 5, in <argument> detected (gomnd)
	videos := make([]*interaction.Video, 5, 10)
	                                     ^
test/interaction/comment_action_test.go:60:35: Error return value of `interactionService.DeleteComment` is not checked (errcheck)
		interactionService.DeleteComment(req)
		                                ^
test/interaction/comment_count_test.go:31:35: Error return value of `interactionService.CountComments` is not checked (errcheck)
		interactionService.CountComments(req)
		                                ^
test/interaction/comment_list_test.go:33:33: Error return value of `interactionService.GetComments` is not checked (errcheck)
		interactionService.GetComments(req)
		                              ^
test/interaction/favorite_action_test.go:37:26: Error return value of `interactionService.Like` is not checked (errcheck)
		interactionService.Like(req, userId)
		                       ^
test/interaction/favorite_action_test.go:38:29: Error return value of `interactionService.Dislike` is not checked (errcheck)
		interactionService.Dislike(req, userId)
		                          ^
test/interaction/favorite_count_test.go:31:34: Error return value of `interactionService.GetLikeCount` is not checked (errcheck)
		interactionService.GetLikeCount(req)
		                               ^
test/interaction/favorite_list_test.go:31:34: Error return value of `interactionService.FavoriteList` is not checked (errcheck)
		interactionService.FavoriteList(req)
		                               ^
test/interaction/comment_action_test.go:53:27: block should not start with a whitespace (wsl)
	for i := 0; i < b.N; i++ {
	                         ^
test/interaction/main_test.go:34:2: only cuddled expressions if assigning variable or using from line above (wsl)
	m.Run()
	^
test/interaction/favorite_count_test.go:25:6: test helper function should start from b.Helper() (thelper)
func benchmarkFavoriteCount(b *testing.B) {
     ^
cmd/chat/service/send_message.go:15:10: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"character limit error\")" (goerr113)
		return errors.New("character limit error")
		       ^
cmd/video/dal/db/video.go:37:98: mnd: Magic number: 30, in <argument> detected (gomnd)
	if err := DB.WithContext(ctx).Where("created_at < ?", latestTime).Order("created_at ASC").Limit(30).Find(&videoResp).Error; err != nil {
	                                                                                                ^
